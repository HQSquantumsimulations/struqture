<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Struqture User Guide</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta name="description" content="User guide for the struqture package to represent physical systems.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="physical_types/intro.html"><strong aria-hidden="true">1.</strong> Physical Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="physical_types/spins.html"><strong aria-hidden="true">1.1.</strong> Spins</a></li><li class="chapter-item expanded "><a href="physical_types/fermions.html"><strong aria-hidden="true">1.2.</strong> Fermions</a></li><li class="chapter-item expanded "><a href="physical_types/bosons.html"><strong aria-hidden="true">1.3.</strong> Bosons</a></li><li class="chapter-item expanded "><a href="physical_types/mixed_systems.html"><strong aria-hidden="true">1.4.</strong> Mixed Systems</a></li></ol></li><li class="chapter-item expanded "><a href="container_types/intro.html"><strong aria-hidden="true">2.</strong> Container Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="container_types/indices.html"><strong aria-hidden="true">2.1.</strong> Indices and Products</a></li><li class="chapter-item expanded "><a href="container_types/operators_hamiltonians_and_systems.html"><strong aria-hidden="true">2.2.</strong> Operators and Systems</a></li><li class="chapter-item expanded "><a href="container_types/operators_hamiltonians_and_systems.html"><strong aria-hidden="true">2.3.</strong> Hamiltonians and Hamiltonian Systems</a></li><li class="chapter-item expanded "><a href="container_types/noise_operators_and_systems.html"><strong aria-hidden="true">2.4.</strong> Lindblad Noise Operators and Lindblad Noise Systems</a></li><li class="chapter-item expanded "><a href="container_types/open_systems.html"><strong aria-hidden="true">2.5.</strong> Lindblad Open Systems</a></li></ol></li><li class="chapter-item expanded "><a href="example.html"><strong aria-hidden="true">3.</strong> Applied Example</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Struqture User Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Struqture is a Rust (struqture) and Python (struqture-py) library by <a href="https://quantumsimulations.de/">HQS Quantum Simulations</a> to represent quantum mechanical operators, Hamiltonians and open quantum systems.
The library supports building <a href="physical_types/spins.html">spin</a> objects, <a href="physical_types/fermions.html">fermionic</a> objects, <a href="physical_types/bosons.html">bosonic</a> objects and <a href="physical_types/mixed_systems.html">mixed system</a> objects that contain arbitrary many spin, fermionic and bosonic subsystems.</p>
<p>Struqture has been developed to create and exchange definitions of operators, Hamiltonians and open systems. A special focus is the use as input to quantum computing simulation software.</p>
<p>To best support this use case, struqture has a number of design goals:</p>
<ul>
<li>Support for arbitrary spin, bosonic, fermionic and mixed systems</li>
<li>Full serialisation support to json and other formats</li>
<li>Preventing construction of unphysical objects by using well defined types for all objects in struqture</li>
<li>Support of symbolic values in operators, Hamiltonians and open systems</li>
</ul>
<p>Following these design goals, we prioritize using distinctive types to construct objects over a less verbose syntax.
Similarly the support of symbolic expression leads to a trade-off in speed compared to an implementation using only floating point values.
The symbolic expression support is achieved by using CalculatorComplex and CalculatorFloat values instead of complex and float values (respectively), which are imported frrom [qoqo_calculator] (https://github.com/HQSquantumsimulations/qoqo_calculator).
Struqture is designed to also support the construction and (de)serialisation of large systems but for the use in numeric algorithms we recommend transforming Operators and Hamiltonians into a sparse matrix form.</p>
<p>This documentation is split into two parts. The <a href="physical_types/intro.html">first part</a> covers the basic usage for spins, bosons, fermions and mixed systems. The <a href="container_types/intro.html">second part</a> covers the shared design patterns between spins, bosons, fermions and mixed systems. A real-world <a href="example.html">example</a> is also included in.</p>
<p>Note: the package will be faster in Rust than Python, as Rust is a compiled language. This should only make a big difference, however, if you are performing hundreds of multiplication operations and a large amount of getter/setter calls. </p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<p>You can install <code>struqture_py</code> from PyPi. For x86 Linux, Windows and macOS systems pre-built wheels are available.
On other platforms a local Rust toolchain is required to compile the Python source distribution.</p>
<pre><code class="language-bash">pip install struqture-py
</code></pre>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>You can use struqture in your Rust project by adding </p>
<pre><code class="language-TOML">struqture = { version = &quot;1.0.0&quot; }
</code></pre>
<p>to your Cargo.toml file.</p>
<h2 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h2>
<p>This user documentation is intended to give a high level overview of the design and usage of struqture. For a full list of the available data types and functions see the API-Documentaions of <a href="https://docs.rs/struqture/">struqture</a> and <a href="pyapi/index.html">struqture-py</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physical-types"><a class="header" href="#physical-types">Physical Types</a></h1>
<p>In this part of the user documentation we show the basic usage of operators, Hamiltonians and open systems for spins, bosons, fermions and mixed systems.
Stuqture is designed to use the same patterns to construct objects across all physical types. There is a large overlap in the user documentation between all physical types.</p>
<ul>
<li><a href="physical_types/./spins.html">spins</a></li>
<li><a href="physical_types/./bosons.html">bosons</a></li>
<li><a href="physical_types/./fermions.html">fermions</a></li>
<li><a href="physical_types/./mixed_systems.html">mixed systems</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spins"><a class="header" href="#spins">Spins</a></h1>
<h2 id="building-blocks"><a class="header" href="#building-blocks">Building blocks</a></h2>
<p>All spin objects in struqture are expressed based on products of either Pauli operators (X, Y, Z) or operators suited to express decoherence (X, iY, Z). The products are built by setting the operators acting on separate spins.</p>
<h3 id="pauliproducts"><a class="header" href="#pauliproducts">PauliProducts</a></h3>
<p>PauliProducts are combinations of SingleSpinOperators on specific qubits. These are the <code>SingleSpinOperators</code>, or Pauli matrices, that are available for PauliProducts:</p>
<ul>
<li>
<p>I: identity matrix
\[
I = \begin{pmatrix}
1 &amp; 0\\
0 &amp; 1
\end{pmatrix}
\]</p>
</li>
<li>
<p>X: Pauli x matrix
\[
X = \begin{pmatrix}
0 &amp; 1\\
1 &amp; 0
\end{pmatrix}
\]</p>
</li>
<li>
<p>Y: Pauli y matrix
\[
Y = \begin{pmatrix}
0 &amp; -i\\
i &amp; 0
\end{pmatrix}
\]</p>
</li>
<li>
<p>Z: Pauli z matrix
\[
Z = \begin{pmatrix}
1 &amp; 0\\
0 &amp; -1
\end{pmatrix}
\]</p>
</li>
</ul>
<h3 id="decoherenceproducts"><a class="header" href="#decoherenceproducts">DecoherenceProducts</a></h3>
<p>DecoherenceProducts are products of a decoherence operators acting on single spins. These <code>SingleDecoherenceOperators</code>
are almost identical to the <code>SinglePauliOperators</code> with the exception of an additional \(i\) factor and are well suited to represent decoherence properties</p>
<ul>
<li>I: identity matrix
\[
\begin{pmatrix}
1 &amp; 0\\
0 &amp; 1
\end{pmatrix}
\]</li>
<li>X: Pauli X matrix
\[
\begin{pmatrix}
0 &amp; 1\\
1 &amp; 0
\end{pmatrix}
\]</li>
<li>iY: Pauli Y matrix multiplied by i
\[
\begin{pmatrix}
0 &amp; 1 \\
-1 &amp; 0
\end{pmatrix}
\]</li>
<li>Z: Pauli z matrix
\[
\begin{pmatrix}
1 &amp; 0\\
0 &amp; -1
\end{pmatrix}
\]</li>
</ul>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>In Python the separate operators can be set via functions. In the python interface a PauliProduct can often be replaced by its unique string representation.</p>
<pre><code class="language-python">from struqture_py.spins import PauliProduct, DecoherenceProduct

# A product of a X acting on spin 0, a Y acting on spin 3 and a Z acting on spin 20
pp = PauliProduct().x(0).y(3).z(20)
# Often equivalent the string representation
pp_string = str(pp)


# A product of a X acting on spin 0, a iY acting on spin 3 and a Z acting on spin 20
dp = DecoherenceProduct().x(0).iy(3).z(20)
# Often equivalent the string representation
dp_string = str(dp)
</code></pre>
<p>In Rust the user can also import enums for the operators acting on single spins. In rust the equivalent string representation cannot be used in function and method arguments.</p>
<pre><code class="language-rust">use struqture::prelude::*;
use struqture::spins::{
    DecoherenceProduct, PauliProduct, SingleDecoherenceOperator, SingleSpinOperator,
};

// A product of a X acting on spin 0, a Y acting on spin 3 and a Z acting on spin 20
let pp = PauliProduct::new().x(0).y(3).z(20);
// Constructing with SingleSpinOperator
let pp_equivalent = PauliProduct::new()
    .set_pauli(0, SingleSpinOperator::X)
    .set_pauli(3, SingleSpinOperator::Y)
    .set_pauli(20, SingleSpinOperator::Z);

// A product of a X acting on spin 0, a Y acting on spin 3 and a Z acting on spin 20
let dp = DecoherenceProduct::new().x(0).iy(3).z(20);
// Constructing with SingleSpinOperator
let dp_equivalent = DecoherenceProduct::new()
    .set_pauli(0, SingleDecoherenceOperator::X)
    .set_pauli(3, SingleDecoherenceOperator::IY)
    .set_pauli(20, SingleDecoherenceOperator::Z);</code></pre>
<h2 id="operators-and-hamiltonians"><a class="header" href="#operators-and-hamiltonians">Operators and Hamiltonians</a></h2>
<p>A good example how complex objects are constructed from operator products are <code>SpinOperators</code> and <code>SpinHamiltonians</code>
(for more information, <a href="physical_types/../container_types/operators_hamiltonians_and_systems.html">see also</a>).</p>
<p>These <code>SpinOperators</code> and <code>SpinHamiltonians</code> represent operators or hamiltonians such as:
\[
\hat{O} = \sum_{j=0}^N \alpha_j \prod_{k} \sigma^{k}_j \\
\sigma^{k} \in \{ X, Y, Z, I \}
\]
where the \(\sigma^{k}_j\) are <code>SinglePauliOperators</code>.</p>
<p>From a programming perspective the operators and Hamiltonians are HashMaps or Dictionaries with the <code>PauliProducts</code> as keys and the coefficients \(\alpha_j\) as values.</p>
<p>In struqture we distinguish between spin operators and hamiltonians to avoid introducing unphysical behaviour by accident.
While both are sums over PauliProducts, hamiltonians are guaranteed to be hermitian. In a spin hamiltonian, this means that the prefactor of each <code>PauliProduct</code> has to be real.</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<p>Here is an example of how to build a <code>SpinOperator</code> and a <code>SpinHamiltonian</code>, in Rust:</p>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::prelude::*;
use struqture::spins::{PauliProduct, SpinOperator, SpinHamiltonian};

// Building the term sigma^x_0 * sigma^z_2: sigma_x acting on qubit 0
// and sigma_z acting on qubit 2
let pp = PauliProduct::new().x(0).z(2);

// O = (1 + 1.5 * i) * sigma^x_0 * sigma^z_2
let mut operator = SpinOperator::new();
operator.add_operator_product(pp.clone(), CalculatorComplex::new(1.0, 1.5)).unwrap();
assert_eq!(operator.get(&amp;pp), &amp;CalculatorComplex::new(1.0, 1.5));
println!(&quot;{}&quot;, operator);

// Or when overwriting the previous value
let mut operator = SpinOperator::new();
operator.set(pp.clone(), CalculatorComplex::new(1.0, 1.5)).unwrap();
println!(&quot;{}&quot;, operator);

// A complex entry is not valid for a SpinHamiltonian
let mut hamiltonian = SpinHamiltonian::new();
// This would fail
hamiltonian.add_operator_product(pp, CalculatorComplex::new(1.0, 1.5)).unwrap();
// This is possible
hamiltonian.add_operator_product(pp, 1.0.into()).unwrap();
println!(&quot;{}&quot;, hamiltonian);</code></pre>
<p>In python, we need to use a <code>SpinSystem</code> and <code>SpinHamiltonianSystem</code> instead of an<code>SpinOperator</code> and <code>SpinHamiltonian</code>. See next section for more details.</p>
<h2 id="systems-and-hamiltoniansystems"><a class="header" href="#systems-and-hamiltoniansystems">Systems and HamiltonianSystems</a></h2>
<p>Following the intention to avoid unphysical behaviour, SpinSystems and SpinHamiltonianSystems are wrappers around SpinOperators and SpinHamiltonians that allow to explicitly set the number of spins of the systems.
When setting or adding a PauliProduct to the systems, it is guaranteed that the spin indices involved cannot exceed the number of spins in the system.
Note that the user can decide to explicitly set the number of spins to be variable.</p>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples</a></h3>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::prelude::*;
use struqture::spins::{PauliProduct, SpinSystem};

let mut system = SpinSystem::new(Some(3));

// This will work
let pp = PauliProduct::new().x(0).z(2);
system
    .add_operator_product(pp, CalculatorComplex::new(1.0, 1.5))
    .unwrap();
println!(&quot;{}&quot;, system);

// This will not work, as the spin index of the PauliProduct is larger than
// the number of the spins in the system (the spin with the smallest index is 0).
let pp_error = PauliProduct::new().z(3);
let error = system.add_operator_product(pp_error, CalculatorComplex::new(1.0, 1.5));
println!(&quot;{:?}&quot;, error);

// This will work because we leave the number of spins dynamic
let mut system = SpinSystem::new(None);
system
    .add_operator_product(PauliProduct::new().z(3), CalculatorComplex::new(1.0, 1.5))
    .unwrap();</code></pre>
<p>The equivalent code in python:</p>
<pre><code class="language-python">from qoqo_calculator_pyo3 import CalculatorComplex
from struqture_py import spins

system = spins.SpinSystem(3)

# This will work
pp = spins.PauliProduct().x(0).z(2)
system.add_operator_product(pp, CalculatorComplex.from_pair(1.0, 1.5))
print(system)

# This will not work, as the spin index of the PauliProduct is larger
# than the number of the spins in the system (the spin with the smallest index is 0).
pp_error = spins.PauliProduct().z(3)
value = CalculatorComplex.from_pair(1.0, 1.5)
# system.add_operator_product(pp_error, value)  # Uncomment me!


# This will work because we leave the number of spins dynamic
system = spins.SpinSystem()
system.add_operator_product(spins.PauliProduct().z(3), 1.0)
</code></pre>
<h2 id="noise-operators-and-systems"><a class="header" href="#noise-operators-and-systems">Noise operators and systems</a></h2>
<p>We describe decoherence by representing it with the Lindblad equation.
The Lindblad equation is a master equation determining the time evolution of the density matrix.
It is given by
\[
\dot{\rho} = \mathcal{L}(\rho) =-i [\hat{H}, \rho] + \sum_{j,k} \Gamma_{j,k} \left( L_{j}\rho L_{k}^{\dagger} - \frac{1}{2} \{ L_k^{\dagger} L_j, \rho \} \right)
\]
with the rate matrix \(\Gamma_{j,k}\) and the Lindblad operator \(L_{j}\).</p>
<p>To describe the pure noise part of the Lindblad equation one needs the rate matrix in a well defined basis of Lindblad operators.
We use <code>DecoherenceProducts</code> as the operator base. To describe spin noise we use the Lindblad equation with \(\hat{H}=0\).</p>
<p>The rate matrix and with it the Lindblad noise model is saved as a sum over pairs of <code>DecoherenceProducts</code>, giving the operators acting from the left and right on the density matrix.
In programming terms the object <code>SpinLindbladNoiseOperator</code> is given by a HashMap or Dictionary with the tuple (<code>DecoherenceProduct</code>, <code>DecoherenceProduct</code>) as keys and the entries in the rate matrix as values.</p>
<p>Similarly to SpinOperators, SpinLindbladNoiseOperators have a system equivalent: <code>SpinLindbladNoiseSystem</code>, with a number of involved spins defined by the user. For more information on these, see the <a href="physical_types/../container_types/noise_operators_and_systems">noise container</a> chapter.</p>
<h3 id="examples-3"><a class="header" href="#examples-3">Examples</a></h3>
<p>Here, we add the terms \( L_0 = \sigma_0^{x} \sigma_2^{z} \) and \( L_1 = \sigma_0^{x} \sigma_2^{z} \) with coefficient 1.0: 
\( 1.0 \left( L_0 \rho L_1^{\dagger} - \frac{1}{2} \{ L_1^{\dagger} L_0, \rho \} \right) \)</p>
<pre><code class="language-rust">use struqture::prelude::*;
use struqture::spins::{DecoherenceProduct, SpinLindbladNoiseSystem};

let mut system = SpinLindbladNoiseSystem::new(Some(3));

let dp = DecoherenceProduct::new().x(0).z(2);

system.add_operator_product((dp.clone(), dp.clone()), 1.0.into()).unwrap();
assert_eq!(system.get(&amp;(dp.clone(), dp)), &amp;CalculatorComplex::new(1.0, 0.0));
println!(&quot;{}&quot;, system);</code></pre>
<p>The equivalent code in python:</p>
<pre><code class="language-python">from struqture_py import spins

system = spins.SpinLindbladNoiseSystem(3)

dp = spins.DecoherenceProduct().x(0).z(2)

system.add_operator_product((dp, dp), 1.0+1.5*1j)
print(system)

# In python we can also use the string representation
system = spins.SpinLindbladNoiseSystem(3)
system.add_operator_product((str(dp), str(dp)), 1.0+1.5*1j)
print(system)
</code></pre>
<h2 id="open-systems"><a class="header" href="#open-systems">Open systems</a></h2>
<p>Physically open systems are quantum systems coupled to an environment that can often be described using Lindblad type of noise.
The Lindblad master equation is given by
\[
\dot{\rho} = \mathcal{L}(\rho) =-i [\hat{H}, \rho] + \sum_{j,k} \Gamma_{j,k} \left( L_{j}\rho L_{k}^{\dagger} - \frac{1}{2} \{ L_k^{\dagger} L_j, \rho \} \right)
\]
In struqture they are composed of a hamiltonian (SpinHamiltonianSystem) and noise (SpinLindbladNoiseSystem). They have different ways to set terms in Rust and Python:</p>
<h3 id="examples-4"><a class="header" href="#examples-4">Examples</a></h3>
<pre><code class="language-rust">use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
use struqture::prelude::*;
use struqture::spins::{DecoherenceProduct, PauliProduct, SpinLindbladOpenSystem};

let mut open_system = SpinLindbladOpenSystem::new(Some(3));

let pp = PauliProduct::new().z(1);
let dp = DecoherenceProduct::new().x(0).z(2);

let system = open_system.system_mut();
system.add_operator_product(pp, CalculatorFloat::from(2.0)).unwrap();

let noise = open_system.noise_mut();
noise
    .add_operator_product((dp.clone(), dp), CalculatorComplex::new(1.0, 0.0))
    .unwrap();

println!(&quot;{}&quot;, open_system);</code></pre>
<p>The equivalent code in python:</p>
<pre><code class="language-python">from qoqo_calculator_pyo3 import CalculatorComplex, CalculatorFloat
from struqture_py import spins

open_system = spins.SpinLindbladOpenSystem(3)

pp = spins.PauliProduct().z(1)
dp = spins.DecoherenceProduct().x(0).z(2)

open_system.system_add_operator_product(pp, CalculatorFloat(2.0))
open_system.noise_add_operator_product(
    (dp, dp), CalculatorComplex.from_pair(0.0, 1.0))

print(open_system)
</code></pre>
<h2 id="matrix-representation-spin-objects-only"><a class="header" href="#matrix-representation-spin-objects-only">Matrix representation: spin objects only</a></h2>
<p>All spin-objects can be converted into sparse matrices with the following convention.
If \(M_2\) corresponds to the matrix acting on spin 2 and \(M_1\) corresponds to the matrix acting on spin 1 the total matrix \(M\) acting on spins 0 to 2 is given by
\[
M = M_2 \otimes M_1 \otimes \mathbb{1}
\]
For an \(N\)-spin system an operator acts on the \(2^N\) dimensional space of state vectors.
A superoperator operates on the \(4^N\) dimensional space of flattened density-matrices.
struqture uses the convention that density matrices are flattened in row-major order
\[
\rho = \begin{pmatrix} a &amp; b \\ c &amp; d \end{pmatrix} =&gt; \vec{\rho} = \begin{pmatrix} a \\ b \\ c \\ d \end{pmatrix}
\]
For noiseless objects (SpinSystem, SpinHamiltonianSystem), sparse operators and sparse superoperators can be constructed, while only sparse superoperators can be constructed for systems with noise (SpinLindbladNoiseSystem, SpinLindbladOpenSystem).</p>
<p>Note that the matrix representation functionality exists only for spin objects, and can't be generated for bosonic, fermionic or mixed system objects.</p>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::prelude::*;
use struqture::spins::{DecoherenceProduct, SpinLindbladNoiseSystem};

let mut system = SpinLindbladNoiseSystem::new(Some(3));

let dp = DecoherenceProduct::new().x(0).z(2);

system
    .add_operator_product((dp.clone(), dp), CalculatorComplex::new(1.0, 0.0))
    .unwrap();

let matrix = system.sparse_matrix_superoperator(Some(3)).unwrap();
println!(&quot;{:?}&quot;, matrix);</code></pre>
<p>The equivalent code in python:</p>
<pre><code class="language-python">from qoqo_calculator_pyo3 import CalculatorComplex
from struqture_py import spins
from scipy.sparse import coo_matrix

system = spins.SpinLindbladNoiseSystem(3)

dp = spins.DecoherenceProduct().x(0).z(2)
system.add_operator_product((dp, dp), CalculatorComplex.from_pair(1.0, 1.5))
# Using the `sparse_matrix_superoperator_coo` function, you can also
# return the information in scipy coo_matrix form, which can be directly fed in:
python_coo = coo_matrix(system.sparse_matrix_superoperator_coo())
print(python_coo.todense())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fermions"><a class="header" href="#fermions">Fermions</a></h1>
<h2 id="building-blocks-1"><a class="header" href="#building-blocks-1">Building blocks</a></h2>
<p>All fermionic objects in struqture are expressed based on products of fermionic creation and annihilation operators, which respect fermionic anti-commutation relations
\[ \lbrace c_k^{\dagger}, c_j^{\dagger} \rbrace = 0, \\
\lbrace c_k, c_j \rbrace = 0, \\
\lbrace c_k^{\dagger}, c_j \rbrace = \delta_{k, j}. \]</p>
<h3 id="fermionproducts"><a class="header" href="#fermionproducts">FermionProducts</a></h3>
<p>FermionProducts are simple combinations of fermionic creation and annihilation operators.</p>
<h3 id="hermitianfermionproducts"><a class="header" href="#hermitianfermionproducts">HermitianFermionProducts</a></h3>
<p>HermitianFermionProducts are the hermitian equivalent of FermionProducts. This means that even though they are constructed the same (see the next section, <code>Examples</code>), they internally store both that term and its hermitian conjugate. For instance, given the term \(c^{\dagger}_0 c_1 c_2\), a FermionProduct would represent \(c^{\dagger}_0 c_1 c_2\) while a HermitianFermionProduct would represent \(c^{\dagger}_0 c_1 c_2 + c^{\dagger}_2 c^{\dagger}_1 c_0\).</p>
<h3 id="examples-5"><a class="header" href="#examples-5">Examples</a></h3>
<p>In both Python and Rust, the operator product is constructed by passing an array or a list of integers to represent the creation indices, and an array or a list of integers to represent the annihilation indices.</p>
<p>Note: (Hermitian)FermionProducts can only been created from the correct ordering of indices (the wrong sequence will return an error) but we have the <code>create_valid_pair</code> function to create a valid Product from arbitrary sequences of operators which also transforms an index value according to the anti-commutation and hermitian conjugation rules.</p>
<pre><code class="language-python">from struqture_py.fermions import FermionProduct, HermitianFermionProduct
from qoqo_calculator_pyo3 import CalculatorComplex

# A product of a creation operator acting on fermionic mode 0 and an
# annihilation operator acting on fermionic mode 20
fp = FermionProduct([0], [20])
# Building the term c^{\dagger}_1 * c^{\dagger}_3 * c_0
fp = FermionProduct.create_valid_pair(
    [3, 1], [0], CalculatorComplex.from_pair(1.0, 0.0))


# A product of a creation operator acting on fermionic mode 0 and an annihilation
# operator acting on fermionic mode 20, as well as a creation operator acting on
# fermionic mode 20 and an annihilation operator acting on fermionic mode 0
hfp = HermitianFermionProduct([0], [20])
# Building the term c^{\dagger}_0 * c^{\dagger}_3 * c_0 + c^{\dagger}_0 * c_3 * c_0
hfp = HermitianFermionProduct.create_valid_pair(
    [3, 0], [0], CalculatorComplex.from_pair(1.0, 0.0))
</code></pre>
<p>In rust the equivalent string representation cannot be used in function and method arguments.</p>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::fermions::{FermionProduct, HermitianFermionProduct};
use struqture::prelude::*;

// Building the term c^{\dagger}_0 c_20
let fp_0 = FermionProduct::new([0], [20]).unwrap();
// Building the term c^{\dagger}_1 * c^{\dagger}_3 * c_0
let (fp_1, coeff) = FermionProduct::create_valid_pair(
    [3, 1], [0], CalculatorComplex::from(1.0)).unwrap();


// A product of a creation operator acting on fermionic mode 0 and an annihilation
// operator acting on fermionic mode 20, as well as a creation operator acting on
// fermionic mode 20 and an annihilation operator acting on fermionic mode 0
let fp_0 = HermitianFermionProduct::new([0], [20]).unwrap();
// Building the term c^{\dagger}_0 * c^{\dagger}_3 * c_0 + c^{\dagger}_0 * c_3 * c_0
let (fp_1, coeff) = HermitianFermionProduct::create_valid_pair(
    [3, 0], [0], CalculatorComplex::from(1.0)).unwrap();</code></pre>
<h2 id="operators-and-hamiltonians-1"><a class="header" href="#operators-and-hamiltonians-1">Operators and Hamiltonians</a></h2>
<p>Complex objects are constructed from operator products are <code>FermionOperators</code> and <code>FermionHamiltonians</code>
(for more information, <a href="physical_types/../container_types/operators_hamiltonians_and_systems.html">see also</a>).</p>
<p>These <code>FermionOperators</code> and <code>FermionHamiltonians</code> represent operators or hamiltonians such as:
\[ \hat{O} = \sum_{j=0}^N \alpha_j \left( \prod_{k=0}^N f(j, k) \right) \left( \prod_{l=0}^N g(j, l) \right) \]
with
\[ f(j, k) = \begin{cases} c_k^{\dagger} \\ 1 \end{cases} , \]
\[ g(j, l) = \begin{cases} c_l \\ 1 \end{cases} , \]
and 
\(c^{\dagger}\) the fermionionic creation operator, \(c\) the fermionionic annihilation operator
\[ \lbrace c_k^{\dagger}, c_j^{\dagger} \rbrace = 0, \\
\lbrace c_k, c_j \rbrace = 0, \\
\lbrace c_k^{\dagger}, c_j \rbrace = \delta_{k, j}. \]</p>
<p>For instance, \(c^{\dagger}_0 c^{\dagger}_1 c_1\) is a term with a \(c^{\dagger}\) term acting on 0, and both a \(c^{\dagger}\) term and a \(c\) term acting on 1.</p>
<p>From a programming perspective the operators and Hamiltonians are HashMaps or Dictionaries with <code>FermionProducts</code> or <code>HermitianFermionProducts</code> (respectively) as keys and the coefficients \(\alpha_j\) as values. </p>
<p>In struqture we distinguish between fermionic operators and hamiltonians to avoid introducing unphysical behaviour by accident.
While both are sums over normal ordered fermionic products (stored as HashMaps of products with a complex prefactor), hamiltonians are guaranteed to be hermitian to avoid introducing unphysical behaviour by accident. In a fermionic hamiltonian, this means that the sums of products are sums of hermitian fermionic products (we have not only the \(c^{\dagger}c\) terms but also their hermitian conjugate) and the on-diagonal terms are required to have real prefactors. We also require the smallest index of the creators to be smaller than the smallest index of the annihilators.</p>
<h3 id="examples-6"><a class="header" href="#examples-6">Examples</a></h3>
<p>Here is an example of how to build a product and using it to build an operator, in Rust:</p>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::prelude::*;
use struqture::fermions::{
    FermionProduct, FermionOperator, HermitianFermionProduct, FermionHamiltonian
};

// Building the term c^{\dagger}_1 * c^{\dagger}_2 * c_0 * c_1
let fp = FermionProduct::new([1, 2], [0, 1]).unwrap();

// O = (1 + 1.5 * i) * c^{\dagger}_1 * c^{\dagger}_2 * c_0 * c_1
let mut operator = FermionOperator::new();
operator.add_operator_product(fp.clone(), CalculatorComplex::new(1.0, 1.5)).unwrap();
println!(&quot;{}&quot;, operator);

// Or when overwriting the previous value
let mut operator = FermionOperator::new();
operator.set(fp.clone(), CalculatorComplex::new(1.0, 1.5)).unwrap();
println!(&quot;{}&quot;, operator);

// A FermionProduct entry is not valid for a FermionHamiltonian
let mut hamiltonian = FermionHamiltonian::new();
// This would fail, as it uses HermitianFermionProducts, not FermionProducts
hamiltonian.add_operator_product(fp, CalculatorComplex::new(1.0, 1.5)).unwrap();
// This is possible
let hfp = HermitianFermionProduct::new([0, 2], [0, 1]).unwrap();
hamiltonian.add_operator_product(hfp, CalculatorComplex::new(1.5, 0.0)).unwrap();
println!(&quot;{}&quot;, hamiltonian);</code></pre>
<p>In python, we need to use a <code>FermionSystem</code> and <code>FermionHamiltonianSystem</code> instead of a <code>FermionOperator</code> and <code>FermionHamiltonian</code>. See next section for more details.</p>
<h2 id="systems-and-hamiltoniansystems-1"><a class="header" href="#systems-and-hamiltoniansystems-1">Systems and HamiltonianSystems</a></h2>
<p>Following the intention to avoid unphysical behaviour, FermionSystems and FermionHamiltonianSystems are wrappers around FermionOperators and FermionHamiltonians that allow to explicitly set the number of spins of the systems.
When setting or adding a FermionProduct/HermitianFermionProduct to the systems, it is guaranteed that the fermionic indices involved cannot exceed the number of fermionic modes in the system.
Note that the user can decide to explicitly set the number of fermionic modes to be variable.</p>
<h3 id="examples-7"><a class="header" href="#examples-7">Examples</a></h3>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::prelude::*;
use struqture::fermions::{HermitianFermionProduct, FermionHamiltonianSystem};

let mut system = FermionHamiltonianSystem::new(Some(3));

// This will work
let hfp = HermitianFermionProduct::new([0, 1], [0, 2]).unwrap();
system.add_operator_product(hfp, CalculatorComplex::new(1.0, 1.5)).unwrap();
println!(&quot;{}&quot;, system);

// This will not work, as the fermionic index of the HermitianFermionProduct is larger
// than the number of the fermionic modes in the system (the fermionic mode with the
// smallest index is 0).
let hfp_error = HermitianFermionProduct::new([3], [3]).unwrap();
let error = system.add_operator_product(hfp_error, CalculatorComplex::new(1.0, 1.5));
println!(&quot;{:?}&quot;, error);

// This will work because we leave the number of spins dynamic
let hbf = HermitianFermionProduct::new([0, 1], [0, 2]).unwrap();
let mut system = FermionHamiltonianSystem::new(None);
system.add_operator_product(hbf, CalculatorComplex::new(1.0, 1.5)).unwrap();</code></pre>
<p>The equivalent code in python:</p>
<pre><code class="language-python">from qoqo_calculator_pyo3 import CalculatorComplex
from struqture_py import fermions

system = fermions.FermionHamiltonianSystem(3)

# This will work
hfp = fermions.HermitianFermionProduct([0, 1], [0, 2])
system.add_operator_product(hfp, CalculatorComplex.from_pair(1.0, 1.5))
print(system)

# This will not work, as the fermioncic index of the HermitianFermionProduct is larger
# than the number of the fermionic modes in the system (the fermionic mode with the
# smallest index is 0).
hfp_error = fermions.HermitianFermionProduct([3], [3])
value = CalculatorComplex.from_pair(1.0, 1.5)
# system.add_operator_product(hfp_error, value)  # Uncomment me!

# This will work because we leave the number of spins dynamic
system = fermions.FermionHamiltonianSystem()
hfp = fermions.HermitianFermionProduct([3], [3])
system.add_operator_product(hfp, CalculatorComplex.from_pair(1.0, 0.0))
</code></pre>
<h2 id="noise-operators-and-systems-1"><a class="header" href="#noise-operators-and-systems-1">Noise operators and systems</a></h2>
<p>We describe decoherence by representing it with the Lindblad equation.
The Lindblad equation is a master equation determining the time evolution of the density matrix.
It is given by
\[
\dot{\rho} = \mathcal{L}(\rho) = -i [\hat{H}, \rho] + \sum_{j,k} \Gamma_{j,k} \left( L_{j}\rho L_{k}^{\dagger} - \frac{1}{2} \{ L_k^{\dagger} L_j, \rho \} \right)
\]
with the rate matrix \(\Gamma_{j,k}\) and the Lindblad operator \(L_{j}\).
To describe the pure noise part of the Lindblad equation one needs the rate matrix in a well defined basis of Lindblad operators.
We use <code>FermionProducts</code> as the operator base. To describe fermionic noise we use the Lindblad equation with \(\hat{H}=0\).</p>
<p>The rate matrix and with it the Lindblad noise model is saved as a sum over pairs of <code>FermionProducts</code>, giving the operators acting from the left and right on the density matrix.
In programming terms the object <code>FermionLindbladNoiseOperator</code> is given by a HashMap or Dictionary with the tuple (<code>FermionProduct</code>, <code>FermionProduct</code>) as keys and the entries in the rate matrix as values.</p>
<p>Similarly to FermionOperators, FermionLindbladNoiseOperators have a system equivalent: <code>FermionLindbladNoiseSystem</code>, with a number of involved fermionic modes defined by the user. For more information on these, see the <a href="physical_types/../container_types/noise_operators_and_systems">noise container</a> chapter.</p>
<h3 id="examples-8"><a class="header" href="#examples-8">Examples</a></h3>
<p>Here, we add the terms \(L_0 = c^{\dagger}_0 c_0\) and \(L_1 = c^{\dagger}_0 c_0\) with coefficient 1.0:
\( 1.0 \left( L_0 \rho L_1^{\dagger} - \frac{1}{2} \{ L_1^{\dagger} L_0, \rho \} \right) \)</p>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::prelude::*;
use struqture::fermions::{FermionProduct, FermionLindbladNoiseSystem};

let mut system = FermionLindbladNoiseSystem::new(Some(3));

let fp = FermionProduct::new([0], [0]).unwrap();

system
    .add_operator_product(
        (fp.clone(), fp.clone()),
        CalculatorComplex::new(1.0, 0.0)
    ).unwrap();
assert_eq!(system.get(&amp;(fp.clone(), fp)), &amp;CalculatorComplex::new(1.0, 0.0));
println!(&quot;{}&quot;, system);</code></pre>
<p>The equivalent code in python:</p>
<pre><code class="language-python">from qoqo_calculator_pyo3 import CalculatorComplex
from struqture_py import fermions

system = fermions.FermionLindbladNoiseSystem(3)

fp = fermions.FermionProduct([0], [0])

system.add_operator_product((fp, fp), CalculatorComplex.from_pair(1.0, 1.5))
print(system)

# In python we can also use the string representation
system = fermions.FermionLindbladNoiseSystem(3)
system.add_operator_product((str(fp), str(fp)), 1.0+1.5*1j)
print(system)
</code></pre>
<h2 id="open-systems-1"><a class="header" href="#open-systems-1">Open systems</a></h2>
<p>Physically open systems are quantum systems coupled to an environment that can often be described using Lindblad type of noise.
The Lindblad master equation is given by
\[
\dot{\rho} = \mathcal{L}(\rho) =-i [\hat{H}, \rho] + \sum_{j,k} \Gamma_{j,k} \left( L_{j}\rho L_{k}^{\dagger} - \frac{1}{2} \{ L_k^{\dagger} L_j, \rho \} \right)
\]
In struqture they are composed of a hamiltonian (FermionHamiltonianSystem) and noise (FermionLindbladNoiseSystem). They have different ways to set terms in Rust and Python:</p>
<h3 id="examples-9"><a class="header" href="#examples-9">Examples</a></h3>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::prelude::*;
use struqture::fermions::{
    FermionProduct, HermitianFermionProduct, FermionLindbladOpenSystem
};

let mut open_system = FermionLindbladOpenSystem::new(Some(3));

let hfp = HermitianFermionProduct::new([0, 1], [0, 2]).unwrap();
let fp = FermionProduct::new([0], [0]).unwrap();

let system = open_system.system_mut();
system.add_operator_product(hfp, CalculatorComplex::new(2.0, 0.0)).unwrap();

let noise = open_system.noise_mut();
noise
    .add_operator_product(
        (fp.clone(), fp), CalculatorComplex::new(1.0, 0.0)
    ).unwrap();

println!(&quot;{}&quot;, open_system);</code></pre>
<p>The equivalent code in python:</p>
<pre><code class="language-python">from qoqo_calculator_pyo3 import CalculatorComplex
from struqture_py import fermions

open_system = fermions.FermionLindbladOpenSystem(3)

hfp = fermions.HermitianFermionProduct([0, 1], [0, 2])
fp = fermions.FermionProduct([0], [0])

open_system.system_add_operator_product(hfp, CalculatorComplex.from_pair(2.0, 0.0))
open_system.noise_add_operator_product(
    (fp, fp), CalculatorComplex.from_pair(0.0, 1.0))

print(open_system)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bosons"><a class="header" href="#bosons">Bosons</a></h1>
<h2 id="building-blocks-2"><a class="header" href="#building-blocks-2">Building blocks</a></h2>
<p>All bosonic objects in struqture are expressed based on products of bosonic creation and annihilation operators, which respect bosonic commutation relations
\[ \lbrack c_k^{\dagger}, c_j^{\dagger} \rbrack = 0, \\
\lbrack c_k, c_j \rbrack = 0, \\
\lbrack c_k^{\dagger}, c_j \rbrack = \delta_{k, j}. \]</p>
<h3 id="bosonproducts"><a class="header" href="#bosonproducts">BosonProducts</a></h3>
<p>BosonProducts are simple combinations of bosonic creation and annihilation operators.</p>
<h3 id="hermitianbosonproducts"><a class="header" href="#hermitianbosonproducts">HermitianBosonProducts</a></h3>
<p>HermitianBosonProducts are the hermitian equivalent of BosonProducts. This means that even though they are constructed the same (see the next section, <code>Examples</code>), they internally store both that term and its hermitian conjugate. For instance, given the term \(c^{\dagger}_0 c_1 c_2\), a BosonProduct would represent \(c^{\dagger}_0 c_1 c_2\) while a HermitianBosonProduct would represent \(c^{\dagger}_0 c_1 c_2 + c^{\dagger}_2 c^{\dagger}_1 c_0\).</p>
<h3 id="examples-10"><a class="header" href="#examples-10">Examples</a></h3>
<p>In both Python and Rust, the operator product is constructed by passing an array or a list of integers to represent the creation indices, and an array or a list of integers to represent the annihilation indices.</p>
<p>Note: (Hermitian)BosonProducts can only been created from the correct ordering of indices (the wrong sequence will return an error) but we have the <code>create_valid_pair</code> function to create a valid Product from arbitrary sequences of operators which also transforms an index value according to the commutation and hermitian conjugation rules.</p>
<pre><code class="language-python">from struqture_py.bosons import BosonProduct, HermitianBosonProduct
from qoqo_calculator_pyo3 import CalculatorComplex

# A product of a creation operator acting on bosonic mode 0 and an annihilation operator
# acting on bosonic mode 20
bp = BosonProduct([0], [20])
# Building the term c^{\dagger}_1 * c^{\dagger}_3 * c_0
bp = BosonProduct.create_valid_pair([3, 1], [0], CalculatorComplex.from_pair(1.0, 0.0))


# A product of a creation operator acting on bosonic mode 0 and an annihilation
# operator acting on bosonic mode 20, as well as a creation operator acting on
# bosonic mode 20 and an annihilation operator acting on bosonic mode 0
hbp = HermitianBosonProduct([0], [20])
# Building the term c^{\dagger}_0 * c^{\dagger}_3 * c_0 + c^{\dagger}_0 * c_3 * c_0
hbp = HermitianBosonProduct.create_valid_pair(
    [3, 0], [0], CalculatorComplex.from_pair(1.0, 0.0))
</code></pre>
<p>In rust the equivalent string representation cannot be used in function and method arguments.</p>
<pre><code class="language-rust">use struqture::bosons::{BosonProduct, HermitianBosonProduct};
use struqture::ModeIndex;
use qoqo_calculator::CalculatorComplex;

// Building the term c^{\dagger}_0 c_20
let bp_0 = BosonProduct::new([0], [20]).unwrap();
// Building the term c^{\dagger}_1 * c^{\dagger}_3 * c_0
let (bp_1, coeff) = BosonProduct::create_valid_pair(
    [3, 1], [0], CalculatorComplex::from(1.0)
).unwrap();


// A product of a creation operator acting on bosonic mode 0 and an annihilation operator
// acting on bosonic mode 20, as well as a creation operator acting on bosonic mode 20
// and an annihilation operator acting on bosonic mode 0
let bp_0 = HermitianBosonProduct::new([0], [20]).unwrap();
// Building the term c^{\dagger}_0 * c^{\dagger}_3 * c_0 + c^{\dagger}_0 * c_3 * c_0
let (bp_1, coeff) = HermitianBosonProduct::create_valid_pair(
    [3, 0], [0], CalculatorComplex::from(1.0)
).unwrap();</code></pre>
<h2 id="operators-and-hamiltonians-2"><a class="header" href="#operators-and-hamiltonians-2">Operators and Hamiltonians</a></h2>
<p>Complex objects are constructed from operator products are <code>BosonOperators</code> and <code>BosonHamiltonians</code>
(for more information, <a href="physical_types/../container_types/operators_hamiltonians_and_systems.html">see also</a>).</p>
<p>These <code>BosonOperators</code> and <code>BosonHamiltonians</code> represent operators or hamiltonians such as:
\[ \hat{O} = \sum_{j=0}^N \alpha_j \left( \prod_{k=0}^N f(j, k) \right) \left( \prod_{l=0}^N g(j, l) \right) \]
with
\[ f(j, k) = \begin{cases} c_k^{\dagger} \\ 1 \end{cases} , \]
\[ g(j, l) = \begin{cases} c_l \\ 1 \end{cases} , \]
and 
\(c^{\dagger}\) the bosonic creation operator, \(c\) the bosonic annihilation operator 
\[ \lbrack c_k^{\dagger}, c_j^{\dagger} \rbrack = 0, \\
\lbrack c_k, c_j \rbrack = 0, \\
\lbrack c_k^{\dagger}, c_j \rbrack = \delta_{k, j}. \]</p>
<p>From a programming perspective the operators and Hamiltonians are HashMaps or Dictionaries with <code>BosonProducts</code> or <code>HermitianBosonProducts</code> (respectively) as keys and the coefficients \(\alpha_j\) as values. </p>
<p>In struqture we distinguish between bosonic operators and hamiltonians to avoid introducing unphysical behaviour by accident.
While both are sums over normal ordered bosonic products (stored as HashMaps of products with a complex prefactor), hamiltonians are guaranteed to be hermitian to avoid introducing unphysical behaviour by accident. In a bosonic hamiltonian, this means that the sums of products are sums of hermitian bosonic products (we have not only the \(c^{\dagger}c\) terms but also their hermitian conjugate) and the on-diagonal terms are required to have real prefactors. We also require the smallest index of the creators to be smaller than the smallest index of the annihilators.</p>
<h3 id="examples-11"><a class="header" href="#examples-11">Examples</a></h3>
<p>Here is an example of how to build a <code>BosonOperator</code> and a <code>BosonHamiltonian</code>, in Rust:</p>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::prelude::*;
use struqture::bosons::{
    BosonProduct, BosonOperator, HermitianBosonProduct, BosonHamiltonian
};

// Building the term c^{\dagger}_1 * c^{\dagger}_2 * c_0 * c_1
let bp = BosonProduct::new([1, 2], [0, 1]).unwrap();

// O = (1 + 1.5 * i) * c^{\dagger}_1 * c^{\dagger}_2 * c_0 * c_1
let mut operator = BosonOperator::new();
operator.add_operator_product(bp.clone(), CalculatorComplex::new(1.0, 1.5)).unwrap();
println!(&quot;{}&quot;, operator);

// Or when overwriting the previous value
let mut operator = BosonOperator::new();
operator.set(bp.clone(), CalculatorComplex::new(1.0, 1.5)).unwrap();
println!(&quot;{}&quot;, operator);

// A BosonProduct entry is not valid for a BosonHamiltonian
let mut hamiltonian = BosonHamiltonian::new();
// This would fail, as it uses HermitianBosonProducts, not BosonProducts
hamiltonian.add_operator_product(bp, CalculatorComplex::new(1.0, 1.5)).unwrap();
// This is possible
let hbp = HermitianBosonProduct::new([0, 2], [0, 1]).unwrap();
hamiltonian.add_operator_product(hbp, CalculatorComplex::new(1.5, 0.0)).unwrap();
println!(&quot;{}&quot;, hamiltonian);</code></pre>
<p>In python, we need to use a <code>BosonSystem</code> and <code>BosonHamiltonianSystem</code> instead of a <code>BosonOperator</code> and <code>BosonHamiltonian</code>. See next section for more details.</p>
<h2 id="systems-and-hamiltoniansystems-2"><a class="header" href="#systems-and-hamiltoniansystems-2">Systems and HamiltonianSystems</a></h2>
<p>Following the intention to avoid unphysical behaviour, BosonSystems and BosonHamiltonianSystems are wrappers around BosonOperators and BosonHamiltonians that allow to explicitly set the number of spins of the systems.
When setting or adding a BosonProduct/HermitianBosonProduct to the systems, it is guaranteed that the bosonic indices involved cannot exceed the number of bosonic modes in the system.
Note that the user can decide to explicitly set the number of bosonic modes to be variable.</p>
<h3 id="examples-12"><a class="header" href="#examples-12">Examples</a></h3>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::prelude::*;
use struqture::bosons::{HermitianBosonProduct, BosonHamiltonianSystem};

let mut system = BosonHamiltonianSystem::new(Some(3));

// This will work
let hbp = HermitianBosonProduct::new([0, 1], [0, 2]).unwrap();
system.add_operator_product(hbp, CalculatorComplex::new(1.0, 1.5)).unwrap();
println!(&quot;{}&quot;, system);

// This will not work, as the bosonic index of the HermitianBosonProduct is larger than
// the number of the bosonic modes in the system (the bosonic mode with the
// smallest index is 0).
let hbp_error = HermitianBosonProduct::new([3], [3]).unwrap();
let error = system.add_operator_product(hbp_error, CalculatorComplex::new(1.0, 1.5));
println!(&quot;{:?}&quot;, error);

// This will work because we leave the number of spins dynamic
let hbp = HermitianBosonProduct::new([0, 1], [0, 2]).unwrap();
let mut system = BosonHamiltonianSystem::new(None);
system.add_operator_product(hbp, CalculatorComplex::new(1.0, 1.5)).unwrap();</code></pre>
<p>The equivalent code in python:</p>
<pre><code class="language-python">from qoqo_calculator_pyo3 import CalculatorComplex
from struqture_py import bosons

system = bosons.BosonHamiltonianSystem(3)

# This will work
hbp = bosons.HermitianBosonProduct([0, 1], [0, 2])
system.add_operator_product(hbp, CalculatorComplex.from_pair(1.0, 1.5))
print(system)

# This will not work, as the bosoncic index of the HermitianBosonProduct
# is larger than the number of the bosonic modes in the system (the bosonic
# mode with the smallest index is 0).
hbp_error = bosons.HermitianBosonProduct([3], [3])
value = CalculatorComplex.from_pair(1.0, 1.5)
# system.add_operator_product(hbp_error, value)  # Uncomment me!

# This will work because we leave the number of spins dynamic
system = bosons.BosonHamiltonianSystem()
hbp = bosons.HermitianBosonProduct([3], [3])
system.add_operator_product(hbp, CalculatorComplex.from_pair(1.0, 0.0))
</code></pre>
<h2 id="noise-operators-and-systems-2"><a class="header" href="#noise-operators-and-systems-2">Noise operators and systems</a></h2>
<p>We describe decoherence by representing it with the Lindblad equation.
The Lindblad equation is a master equation determining the time evolution of the density matrix.
It is given by
\[
\dot{\rho} = \mathcal{L}(\rho) = -i [\hat{H}, \rho] + \sum_{j,k} \Gamma_{j,k} \left( L_{j}\rho L_{k}^{\dagger} - \frac{1}{2} \{ L_k^{\dagger} L_j, \rho \} \right)
\]
with the rate matrix \(\Gamma_{j,k}\) and the Lindblad operator \(L_{j}\).
To describe the pure noise part of the Lindblad equation one needs the rate matrix in a well defined basis of Lindblad operators.
We use <code>BosonProducts</code> as the operator base. To describe bosonic noise we use the Lindblad equation with \(\hat{H}=0\).</p>
<p>The rate matrix and with it the Lindblad noise model is saved as a sum over pairs of <code>BosonProducts</code>, giving the operators acting from the left and right on the density matrix.
In programming terms the object <code>BosonLindbladNoiseOperator</code> is given by a HashMap or Dictionary with the tuple (<code>BosonProduct</code>, <code>BosonProduct</code>) as keys and the entries in the rate matrix as values.</p>
<p>Similarly to BosonOperators, BosonLindbladNoiseOperators have a system equivalent: <code>BosonLindbladNoiseSystem</code>, with a number of involved bosonic modes defined by the user. For more information on these, see the <a href="physical_types/../container_types/noise_operators_and_systems">noise container</a> chapter.</p>
<h3 id="examples-13"><a class="header" href="#examples-13">Examples</a></h3>
<p>Here, we add the terms \(L_0 = c^{\dagger}_0 c_0\) and \(L_1 = c^{\dagger}_0 c_0\) with coefficient 1.0:
\( 1.0 \left( L_0 \rho L_1^{\dagger} - \frac{1}{2} \{ L_1^{\dagger} L_0, \rho \} \right) \)</p>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::prelude::*;
use struqture::bosons::{BosonProduct, BosonLindbladNoiseSystem};

let mut system = BosonLindbladNoiseSystem::new(Some(3));

let bp = BosonProduct::new([0], [0]).unwrap();

system
    .add_operator_product(
        (bp.clone(), bp.clone()), CalculatorComplex::new(1.0, 0.0)
    ).unwrap();
assert_eq!(system.get(&amp;(bp.clone(), bp)), &amp;CalculatorComplex::new(1.0, 0.0));
println!(&quot;{}&quot;, system);</code></pre>
<p>The equivalent code in python:</p>
<pre><code class="language-python">from qoqo_calculator_pyo3 import CalculatorComplex
from struqture_py import bosons

system = bosons.BosonLindbladNoiseSystem(3)

bp = bosons.BosonProduct([0], [0])

system.add_operator_product((bp, bp), CalculatorComplex.from_pair(1.0, 1.5))
print(system)

# In python we can also use the string representation
system = bosons.BosonLindbladNoiseSystem(3)
system.add_operator_product((str(bp), str(bp)), 1.0+1.5*1j)
print(system)
</code></pre>
<h2 id="open-systems-2"><a class="header" href="#open-systems-2">Open systems</a></h2>
<p>Physically open systems are quantum systems coupled to an environment that can often be described using Lindblad type of noise.
The Lindblad master equation is given by
\[
\dot{\rho} = \mathcal{L}(\rho) =-i [\hat{H}, \rho] + \sum_{j,k} \Gamma_{j,k} \left( L_{j}\rho L_{k}^{\dagger} - \frac{1}{2} \{ L_k^{\dagger} L_j, \rho \} \right)
\]
In struqture they are composed of a hamiltonian (BosonHamiltonianSystem) and noise (BosonLindbladNoiseSystem). They have different ways to set terms in Rust and Python:</p>
<h3 id="examples-14"><a class="header" href="#examples-14">Examples</a></h3>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::prelude::*;
use struqture::bosons::{BosonProduct, HermitianBosonProduct, BosonLindbladOpenSystem};

let mut open_system = BosonLindbladOpenSystem::new(Some(3));

let hbp = HermitianBosonProduct::new([0, 1], [0, 2]).unwrap();
let bp = BosonProduct::new([0], [0]).unwrap();

let system = open_system.system_mut();
system.add_operator_product(hbp, CalculatorComplex::new(2.0, 0.0)).unwrap();

let noise = open_system.noise_mut();
noise
    .add_operator_product((bp.clone(), bp), CalculatorComplex::new(1.0, 0.0))
    .unwrap();

println!(&quot;{}&quot;, open_system);</code></pre>
<p>The equivalent code in python:</p>
<pre><code class="language-python">from qoqo_calculator_pyo3 import CalculatorComplex
from struqture_py import bosons

open_system = bosons.BosonLindbladOpenSystem(3)

hbp = bosons.HermitianBosonProduct([0, 1], [0, 2])
bp = bosons.BosonProduct([0], [0])

open_system.system_add_operator_product(hbp, CalculatorComplex.from_pair(2.0, 0.0))
open_system.noise_add_operator_product(
    (bp, bp), CalculatorComplex.from_pair(0.0, 1.0))

print(open_system)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mixed-systems"><a class="header" href="#mixed-systems">Mixed Systems</a></h1>
<h2 id="building-blocks-3"><a class="header" href="#building-blocks-3">Building blocks</a></h2>
<p>All the mixed operators are expressed based on products of mixed indices which contain spin terms, bosonic terms and fermionic terms. The spin terms respect Pauli operator cyclicity, the bosonic terms respect bosonic commutation relations, and the fermionic terms respect fermionic anti-commutation relations.</p>
<p>These products respect the following relations:
\[
-i \sigma^x \sigma^y \sigma^z = I
\]
\[ \lbrack c_{b, k}^{\dagger}, c_{b, j}^{\dagger} \rbrack = 0, \\
\lbrack c_{b, k}, c_{b, j} \rbrack = 0, \\
\lbrack c_{b, k}^{\dagger}, c_{b, j} \rbrack = \delta_{k, j}. \]
\[ \lbrace c_{f, k}^{\dagger}, c_{f, j}^{\dagger} \rbrace = 0, \\
\lbrace c_{f, k}, c_{f, j} \rbrace = 0, \\
\lbrace c_{f, k}^{\dagger}, c_{f, j} \rbrace = \delta_{k, j}. \]</p>
<p>with 
\(c_b^{\dagger}\) the bosonic creation operator, \(c_b\) the bosonic annihilation operator, \(\lbrack ., . \rbrack\) the bosonic commutation relations, \(c_f^{\dagger}\) the fermionic creation operator, \(c_f\) the fermionic annihilation operator, and \(\lbrace ., . \rbrace\) the fermionic anti-commutation relations.</p>
<h3 id="mixedproducts"><a class="header" href="#mixedproducts">MixedProducts</a></h3>
<p>MixedProducts are combinations of <code>PauliProducts</code>, <code>BosonProducts</code> and <code>FermionProducts</code>.</p>
<h3 id="hermitianmixedproducts"><a class="header" href="#hermitianmixedproducts">HermitianMixedProducts</a></h3>
<p>HermitianMixedProducts are the hermitian equivalent of MixedProducts. This means that even though they are constructed the same (see the <code>Examples</code> section), they internally store both that term and its hermitian conjugate. </p>
<h3 id="mixeddecoherenceproducts"><a class="header" href="#mixeddecoherenceproducts">MixedDecoherenceProducts</a></h3>
<p>MixedDecoherenceProducts are combinations of <code>DecoherenceProducts</code>, <code>BosonProducts</code> and <code>FermionProducts</code>.</p>
<h3 id="examples-15"><a class="header" href="#examples-15">Examples</a></h3>
<p>In both Python and Rust, the operator product is constructed by passing an array/a list of spin terms, an array/a list of bosonic terms and an array/a list of fermionic terms.</p>
<pre><code class="language-python">from struqture_py import mixed_systems, bosons, spins, fermions

# Building the spin term sigma^x_0 sigma^z_1
pp = spins.PauliProduct().x(0).z(1)
# Building the bosonic term c_b^{\dagger}_1 * c_b^{\dagger}_2 * c_b_0 * c_b_1
bp = bosons.BosonProduct([1, 2], [1])
# Building the fermionic term c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1
fp = fermions.FermionProduct([0, 1], [0, 1])

# Building the term sigma^x_0 sigma^z_1 c_b^{\dagger}_1 * c_b^{\dagger}_2
# * c_b_0 * c_b_1 * c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1
hmp = mixed_systems.MixedProduct([pp], [bp], [fp])

# Building the term sigma^x_0 sigma^z_1 c_b^{\dagger}_1 * c_b^{\dagger}_2 *
# c_b_0 * c_b_1 * c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1  +  h.c.
hmp = mixed_systems.HermitianMixedProduct([pp], [bp], [fp])


# Building the spin term sigma^x_0 sigma^z_1
dp = spins.DecoherenceProduct().x(0).z(1)
# Building the bosonic term c_b^{\dagger}_1 * c_b^{\dagger}_2 * c_b_0 * c_b_1
bp = bosons.BosonProduct([1, 2], [0, 1])
# Building the fermionic term c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1
fp = fermions.FermionProduct([0, 1], [0, 1])

# This will work
mdp = mixed_systems.MixedDecoherenceProduct([dp], [bp], [fp])
</code></pre>
<p>In rust the equivalent string representation cannot be used in function and method arguments.</p>
<pre><code class="language-rust">use struqture::prelude::*;
use struqture::spins::{DecoherenceProduct, PauliProduct};
use struqture::bosons::BosonProduct;
use struqture::fermions::FermionProduct;
use struqture::mixed_systems::{
    MixedProduct, HermitianMixedProduct, MixedDecoherenceProduct
};

// Building the spin term sigma^x_0 sigma^z_1
let pp = PauliProduct::new().x(0).z(1);
// Building the bosonic term c_b^{\dagger}_1 * c_b^{\dagger}_2 * c_b_0 * c_b_1
let bp = BosonProduct::new([1, 2], [0, 1]).unwrap();
// Building the fermionic term c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1
let fp = FermionProduct::new([0, 1], [0, 1]).unwrap();

// Building the term sigma^x_0 sigma^z_1 c_b^{\dagger}_1 * c_b^{\dagger}_2
// * c_b_0 * c_b_1 * c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1
let mp = MixedProduct::new([pp.clone()], [bp.clone()], [fp.clone()]).unwrap();

// Building the term sigma^x_0 sigma^z_1 c_b^{\dagger}_1 * c_b^{\dagger}_2 * c_b_0
// * c_b_1 * c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1  +  h.c.
let hmp = HermitianMixedProduct::new([pp], [bp], [fp]).unwrap();


// Building the spin term sigma^x_0 sigma^z_1
let dp = DecoherenceProduct::new().x(0).z(1);
// Building the bosonic term c_b^{\dagger}_1 * c_b^{\dagger}_2 * c_b_0 * c_b_1
let bp = BosonProduct::new([1, 2], [0, 1]).unwrap();
// Building the fermionic term c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1
let fp = FermionProduct::new([0, 1], [0, 1]).unwrap();

// Building the term sigma^x_0 sigma^z_1 c_b^{\dagger}_1 * c_b^{\dagger}_2 * c_b_0
// * c_b_1 * c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1
let mdp = MixedDecoherenceProduct::new([dp], [bp], [fp]).unwrap();
</code></pre>
<h2 id="operators-and-hamiltonians-3"><a class="header" href="#operators-and-hamiltonians-3">Operators and Hamiltonians</a></h2>
<p>Complex objects are constructed from operator products are <code>MixedOperators</code> and <code>MixedHamiltonians</code>
(for more information, <a href="physical_types/../container_types/operators_hamiltonians_and_systems.html">see also</a>).</p>
<p>These <code>MixedOperators</code> and <code>MixedHamiltonians</code> represent operators or hamiltonians such as:
\[ \hat{H} = \sum_{j=0}^N \alpha_j \prod_{k} \sigma_j^{k}  \prod_{l, m} c_{b, l, j}^{\dagger} c_{b, m, j} \prod_{r, s} c_{f, r, j}^{\dagger} c_{f, s, j} \]
with commutation relations and cyclicity respected.</p>
<p>From a programming perspective the operators and Hamiltonians are HashMaps or Dictionaries with <code>MixedProducts</code> or <code>HermitianMixedProducts</code> (respectively) as keys and the coefficients \(\alpha_j\) as values. </p>
<p>In struqture we distinguish between mixed operators and hamiltonians to avoid introducing unphysical behaviour by accident.
While both are sums over normal ordered mixed products (stored as HashMaps of products with a complex prefactor), hamiltonians are guaranteed to be hermitian to avoid introducing unphysical behaviour by accident. In a mixed hamiltonian, this means that the sums of products are sums of hermitian mixed products (we have not only the \(c^{\dagger}c\) terms but also their hermitian conjugate) and the on-diagonal terms are required to have real prefactors. We also require the smallest index of the creators to be smaller than the smallest index of the annihilators.</p>
<p>For <code>MixedOperators</code> and <code>MixedHamiltonians</code>, we need to specify the number of spin subsystems, bosonic subsystems and fermionic subsystems exist in the operator/hamiltonian. See the example for more information.</p>
<h3 id="examples-16"><a class="header" href="#examples-16">Examples</a></h3>
<p>Here is an example of how to build a <code>MixedOperator</code> and a <code>MixedHamiltonian</code>, in Rust:</p>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::prelude::*;
use struqture::bosons::BosonProduct;
use struqture::fermions::FermionProduct;
use struqture::spins::PauliProduct;
use struqture::mixed_systems::{
    MixedOperator, MixedProduct, HermitianMixedProduct, MixedHamiltonian
};

// Building the spin term sigma^x_0 sigma^z_1
let pp_0 = PauliProduct::new().x(0).z(1);
// Building the spin term sigma^y_0
let pp_1 = PauliProduct::new().y(0);
// Building the bosonic term c_b^{\dagger}_1 * c_b^{\dagger}_2 * c_b_0 * c_b_1
let bp = BosonProduct::new([1, 2], [1]).unwrap();
// Building the fermionic term c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1
let fp = FermionProduct::new([0, 1], [0, 1]).unwrap();

// Building the term sigma^x_0 sigma^z_1 c_b^{\dagger}_1 * c_b^{\dagger}_2
// * c_b_0 * c_b_1 * c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1
let mp_0 = MixedProduct::new([pp_0.clone()], [bp.clone()], [fp.clone()]).unwrap();
// Building the term sigma^y_0
let mp_1 = MixedProduct::new(
    [pp_1.clone()],
    [BosonProduct::new([], []).unwrap()],
    [FermionProduct::new([], []).unwrap()]
).unwrap();

// Building the operator
let mut operator = MixedOperator::new(1, 1, 1);
operator.add_operator_product(mp_0.clone(), CalculatorComplex::new(1.0, 1.5)).unwrap();
operator.add_operator_product(mp_1.clone(), CalculatorComplex::from(2.0)).unwrap();
println!(&quot;{}&quot;, operator);

// Or when overwriting the previous value
let mut operator = MixedOperator::new(1, 1, 1);
operator.set(mp_0, CalculatorComplex::new(1.0, 1.5)).unwrap();
operator.set(mp_1, CalculatorComplex::from(2.0)).unwrap();
println!(&quot;{}&quot;, operator);


// Building the term sigma^x_0 sigma^z_1 c_b^{\dagger}_1 * c_b^{\dagger}_2
// * c_b_0 * c_b_1 * c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1
let hmp_0 = HermitianMixedProduct::new([pp_0], [bp], [fp]).unwrap();
// Building the term sigma^y_0
let hmp_1 = HermitianMixedProduct::new(
    [pp_1],
    [BosonProduct::new([], []).unwrap()],
    [FermionProduct::new([], []).unwrap()]
).unwrap();

// Building the operator
let mut hamiltonian = MixedHamiltonian::new(1, 1, 1);
hamiltonian.add_operator_product(hmp_0, CalculatorComplex::new(1.0, 1.5)).unwrap();
hamiltonian.add_operator_product(hmp_1, CalculatorComplex::from(2.0)).unwrap();
println!(&quot;{}&quot;, hamiltonian);</code></pre>
<p>In python, we need to use a <code>MixedSystem</code> and <code>MixedHamiltonianSystem</code> instead of a <code>MixedOperator</code> and <code>MixedHamiltonian</code>. See next section for more details.</p>
<h2 id="systems-and-hamiltoniansystems-3"><a class="header" href="#systems-and-hamiltoniansystems-3">Systems and HamiltonianSystems</a></h2>
<p>Following the intention to avoid unphysical behaviour, MixedSystems and MixedHamiltonianSystems are wrappers around MixedOperators and MixedHamiltonians that allow to explicitly set the number of spins, the number of bosonic modes and the number of fermionic modes in each subsystem of the systems.
When setting or adding a MixedProduct/HermitianMixedProduct to the systems, it is guaranteed that the mixed indices involved cannot exceed the number of spins, bosonic modes, and fermionic modes (for each subsystem) in the system. 
Additionally, the correct number of subsystems needs to have been specified for each type.
Note that the user can decide to explicitly set the number of of each particle type to be variable.</p>
<h3 id="examples-17"><a class="header" href="#examples-17">Examples</a></h3>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::bosons::BosonProduct;
use struqture::fermions::FermionProduct;
use struqture::mixed_systems::{HermitianMixedProduct, MixedHamiltonianSystem};
use struqture::prelude::*;
use struqture::spins::PauliProduct;

let mut system = MixedHamiltonianSystem::new([Some(2), Some(1)], [Some(3)], [Some(3)]);

// Building the spin term sigma^x_0 sigma^z_1
let pp_0 = PauliProduct::new().x(0).z(1);
// Building the spin term sigma^y_0
let pp_1 = PauliProduct::new().y(0);
// Building the bosonic term c_b^{\dagger}_1 * c_b^{\dagger}_2 * c_b_0 * c_b_1
let bp = BosonProduct::new([1, 2], [1]).unwrap();
// Building the fermionic term c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1
let fp = FermionProduct::new([0, 1], [0, 1]).unwrap();

// This will work
let hmp = HermitianMixedProduct::new(
    [pp_0.clone(), pp_1.clone()],
    [bp],
    [fp.clone()]
).unwrap();
system
    .add_operator_product(hmp, CalculatorComplex::new(1.0, 1.5))
    .unwrap();
println!(&quot;{}&quot;, system);

// This will not work, as the number of subsystems of the system and
// product do not match.
let hmp_error = HermitianMixedProduct::new(
    [pp_0, pp_1.clone()],
    [],
    [fp.clone()]
).unwrap();
let error = system.add_operator_product(hmp_error, CalculatorComplex::new(1.0, 1.5));
println!(&quot;{:?}&quot;, error);

// This will not work, as the number of spins in the first
// subsystem of the system and product do not match.
let pp_error = PauliProduct::new().x(10);
let hmp_error = HermitianMixedProduct::new(
    [pp_error.clone(), pp_1.clone()],
    [BosonProduct::new([], []).unwrap()],
    [fp.clone()],
)
.unwrap();
let error = system.add_operator_product(hmp_error, CalculatorComplex::new(1.0, 1.5));
println!(&quot;{:?}&quot;, error);

// This will work because we leave the number of spins dynamic
let hmp = HermitianMixedProduct::new(
    [pp_error, pp_1],
    [BosonProduct::new([], []).unwrap()],
    [fp]
).unwrap();
let mut system = MixedHamiltonianSystem::new([None, None], [None], [None]);
system
    .add_operator_product(hmp, CalculatorComplex::new(1.0, 0.0))
    .unwrap();</code></pre>
<p>The equivalent code in python:</p>
<pre><code class="language-python">from qoqo_calculator_pyo3 import CalculatorComplex
from struqture_py import bosons, fermions, spins, mixed_systems

system = mixed_systems.MixedHamiltonianSystem([2, 1], [3], [3])

# Building the spin term sigma^x_0 sigma^z_1
pp_0 = spins.PauliProduct().x(0).z(1)
# Building the spin term sigma^y_0
pp_1 = spins.PauliProduct().y(0)
# Building the bosonic term c_b^{\dagger}_1 * c_b^{\dagger}_2 * c_b_0 * c_b_1
bp = bosons.BosonProduct([1, 2], [1])
# Building the fermionic term c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1
fp = fermions.FermionProduct([0, 1], [0, 1])

# This will work
hmp = mixed_systems.HermitianMixedProduct([pp_0, pp_1], [bp], [fp])
system.add_operator_product(hmp, CalculatorComplex.from_pair(1.0, 1.5))
print(system)

# This will not work, as the number of subsystems of the
# system and product do not match.
hmp_error = mixed_systems.HermitianMixedProduct([pp_0, pp_1], [], [fp])
value = CalculatorComplex.from_pair(1.0, 1.5)
# system.add_operator_product(hmp_error, value)  # Uncomment me!

# This will not work, as the number of spins in the first subsystem
# of the system and product do not match.
pp_error = spins.PauliProduct().x(10)
hmp_error = mixed_systems.HermitianMixedProduct(
    [pp_error, pp_1], [bosons.BosonProduct([], [])], [fp])
# system.add_operator_product(hmp_error, value)  # Uncomment me!

# This will work because we leave the number of spins dynamic.
hmp = mixed_systems.HermitianMixedProduct(
    [pp_error, pp_1], [bosons.BosonProduct([], [])], [fp])
system = mixed_systems.MixedHamiltonianSystem([None, None], [None], [None])
system.add_operator_product(hmp_error, CalculatorComplex.from_pair(1.0, 0.0))
</code></pre>
<h2 id="noise-operators-and-systems-3"><a class="header" href="#noise-operators-and-systems-3">Noise operators and systems</a></h2>
<p>We describe decoherence by representing it with the Lindblad equation.
The Lindblad equation is a master equation determining the time evolution of the density matrix.
It is given by
\[
\dot{\rho} = \mathcal{L}(\rho) =-i [\hat{H}, \rho] + \sum_{j,k} \Gamma_{j,k} \left( L_{j}\rho L_{k}^{\dagger} - \frac{1}{2} \{ L_k^{\dagger} L_j, \rho \} \right)
\]
with the rate matrix \(\Gamma_{j,k}\) and the Lindblad operator \(L_{j}\).
To describe the pure noise part of the Lindblad equation one needs the rate matrix in a well defined basis of Lindblad operators.
We use <code>MixedDecoherenceProducts</code> as the operator base. To describe mixed noise we use the Lindblad equation with \(\hat{H}=0\).</p>
<p>The rate matrix and with it the Lindblad noise model is saved as a sum over pairs of <code>MixedDecoherenceProducts</code>, giving the operators acting from the left and right on the density matrix.
In programming terms the object <code>MixedLindbladNoiseOperators</code> is given by a HashMap or Dictionary with the tuple (<code>MixedDecoherenceProduct</code>, <code>MixedDecoherenceProduct</code>) as keys and the entries in the rate matrix as values.</p>
<p>Similarly to MixedOperators, MixedLindbladNoiseOperators have a system equivalent: <code>MixedLindbladNoiseOperators</code>, with a number of involved spins, bosonic modes and fermionic modes (for each subsystem) defined by the user. For more information on these, see the <a href="physical_types/../container_types/noise_operators_and_systems">noise container</a> chapter.</p>
<h3 id="examples-18"><a class="header" href="#examples-18">Examples</a></h3>
<p>Here, we add the terms \(L_0 = \left( \sigma_0^x \sigma_1^z \right) \left( c_{b, 1}^{\dagger} c_{b, 1} \right) \left( c_{f, 0}^{\dagger} c_{f, 1}^{\dagger} c_{f, 0} c_{f, 1} \right)\) and \(L_1 = \left( \sigma_0^x \sigma_1^z \right) \left( c_{b, 1}^{\dagger} c_{b, 1} \right) \left( c_{f, 0}^{\dagger} c_{f, 1}^{\dagger} c_{f, 0} c_{f, 1} \right)\) with coefficient 1.0:
\( 1.0 \left( L_0 \rho L_1^{\dagger} - \frac{1}{2} \{ L_1^{\dagger} L_0, \rho \} \right) \)</p>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::bosons::BosonProduct;
use struqture::fermions::FermionProduct;
use struqture::mixed_systems::{MixedDecoherenceProduct, MixedLindbladNoiseSystem};
use struqture::prelude::*;
use struqture::spins::DecoherenceProduct;

let mut system = MixedLindbladNoiseSystem::new([Some(3)], [Some(3)], [Some(3)]);

// Building the spin term sigma^x_0 sigma^z_1
let pp = DecoherenceProduct::new().x(0).z(1);
// Building the bosonic term c_b^{\dagger}_1 * c_b^{\dagger}_2 * c_b_0 * c_b_1
let bp = BosonProduct::new([1], [1]).unwrap();
// Building the fermionic term c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1
let fp = FermionProduct::new([0, 1], [0, 1]).unwrap();

// Building the term sigma^x_0 sigma^z_1 * c_b^{\dagger}_2 * c_b_0
// * c_b_1 * c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1
let mdp = MixedDecoherenceProduct::new(
    [pp],
    [bp],
    [fp]
).unwrap();

system
    .add_operator_product(
        (mdp.clone(), mdp.clone()),
        CalculatorComplex::new(1.0, 1.5),
    )
    .unwrap();
assert_eq!(
    system.get(&amp;(mdp.clone(), mdp)),
    &amp;CalculatorComplex::new(1.0, 1.5)
);
println!(&quot;{}&quot;, system);</code></pre>
<p>The equivalent code in python:</p>
<pre><code class="language-python">from qoqo_calculator_pyo3 import CalculatorComplex
from struqture_py import bosons, fermions, spins, mixed_systems

system = mixed_systems.MixedLindbladNoiseSystem([3], [3], [3])

# Building the spin term sigma^x_0 sigma^z_1
pp_0 = spins.DecoherenceProduct().x(0).z(1)
# Building the bosonic term c_b^{\dagger}_1 * c_b^{\dagger}_2 * c_b_0 * c_b_1
bp = bosons.BosonProduct([0], [0])
# Building the fermionic term c_f^{\dagger}_0 * c_f^{\dagger}_1 * c_f_0 * c_f_1
fp = fermions.FermionProduct([0, 1], [0, 1])

# Building the term sigma^x_0 sigma^z_1 * c_f^{\dagger}_0
# * c_b^{\dagger}_0 * c_b^{\dagger}_1 * c_f^{\dagger}_1 * c_f_0 * c_f_1
mdp = mixed_systems.MixedDecoherenceProduct([pp], [bp], [fp])

system.add_operator_product(
    (mdp, mdp), CalculatorComplex.from_pair(1.0, 1.5))
print(system)

# In python we can also use the string representation
system = mixed_systems.MixedLindbladNoiseSystem([3], [3], [3])
system.add_operator_product((str(mdp), str(mdp)), 1.0+1.5*1j)
print(system)
</code></pre>
<h2 id="open-systems-3"><a class="header" href="#open-systems-3">Open systems</a></h2>
<p>Physically open systems are quantum systems coupled to an environment that can often be described using Lindblad type of noise.
The Lindblad master equation is given by
\[
\dot{\rho} = \mathcal{L}(\rho) =-i [\hat{H}, \rho] + \sum_{j,k} \Gamma_{j,k} \left( L_{j}\rho L_{k}^{\dagger} - \frac{1}{2} \{ L_k^{\dagger} L_j, \rho \} \right)
\]</p>
<p>In struqture they are composed of a hamiltonian (MixedHamiltonianSystem) and noise (MixedLindbladNoiseSystem). They have different ways to set terms in Rust and Python:</p>
<h3 id="examples-19"><a class="header" href="#examples-19">Examples</a></h3>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::bosons::BosonProduct;
use struqture::fermions::FermionProduct;
use struqture::mixed_systems::{
    HermitianMixedProduct, MixedDecoherenceProduct, MixedLindbladOpenSystem,
};
use struqture::prelude::*;
use struqture::spins::{DecoherenceProduct, PauliProduct};

let mut open_system = MixedLindbladOpenSystem::new([Some(3)], [Some(3)], [Some(3)]);

let pp = PauliProduct::new().x(0).z(1);
let bp = BosonProduct::new([0], [0]).unwrap();
let fp = FermionProduct::new([0, 1], [0, 1]).unwrap();

let hmp = HermitianMixedProduct::new([pp], [bp], [fp]).unwrap();

let pp = DecoherenceProduct::new().x(0).z(1);
let bp = BosonProduct::new([1], [1]).unwrap();
let fp = FermionProduct::new([0, 1], [0, 1]).unwrap();

let mdp = MixedDecoherenceProduct::new([pp], [bp], [fp]).unwrap();

let system = open_system.system_mut();
system
    .add_operator_product(hmp, CalculatorComplex::new(2.0, 0.0))
    .unwrap();

let noise = open_system.noise_mut();
noise
    .add_operator_product((mdp.clone(), mdp), CalculatorComplex::new(1.0, 0.0))
    .unwrap();

println!(&quot;{}&quot;, open_system);</code></pre>
<p>The equivalent code in python:</p>
<pre><code class="language-python">from qoqo_calculator_pyo3 import CalculatorComplex
from struqture_py import bosons, fermions, spins, mixed_systems

open_system = mixed_systems.MixedLindbladOpenSystem([3], [3], [3])

pp = spins.PauliProduct().x(0).z(1)
bp = bosons.BosonProduct([1, 2], [1])
fp = fermions.FermionProduct([0, 1], [0, 1])

hmp = mixed_systems.HermitianMixedProduct([pp], [bp], [fp])

dp = spins.DecoherenceProduct().x(0).z(1)
bp = bosons.BosonProduct([1], [1])
fp = fermions.FermionProduct([0, 1], [0, 1])

mdp = mixed_systems.MixedDecoherenceProduct([dp], [bp], [fp])

open_system.system_add_operator_product(hmp, CalculatorComplex.from_pair(2.0, 0.0))
open_system.noise_add_operator_product(
    (mdp, mdp), CalculatorComplex.from_pair(0.0, 1.0))

print(open_system)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container-types"><a class="header" href="#container-types">Container Types</a></h1>
<p>This part of the user documentation focuses on the shared patterns between all physical types: spins, fermions, bosons and mixed systems.
All container types for operators, Hamiltonians and open systems behave like hash maps or dictionaries with products of fundamental quantum operators as keys.</p>
<p>The following container types are available, regardless of physical type:</p>
<ul>
<li><a href="container_types/./indices.html">indices</a></li>
<li><a href="container_types/./operators_hamiltonians_and_systems.html">operators</a></li>
<li><a href="container_types/./operators_hamiltonians_and_systems.html">hamiltonians</a></li>
<li><a href="container_types/./operators_hamiltonians_and_systems.html">systems</a></li>
<li><a href="container_types/./operators_hamiltonians_and_systems.html">hamiltonian systems</a></li>
<li><a href="container_types/./noise_operators_and_systems.html">noise operators</a></li>
<li><a href="container_types/./noise_operators_and_systems.html">noise systems</a></li>
<li><a href="container_types/./open_systems.html">open systems</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="products-and-indices"><a class="header" href="#products-and-indices">Products and Indices</a></h1>
<p>The fundamental design of struqture uses products of quantum operators acting on single spins or modes to build up all represented objects. For spins those are <code>SinglePauliOperator</code> and <code>SingleDecoherenceOperator</code> and for Fermions and Bosons those are simply fermionic creation and annihilation operators.</p>
<p>Since these operators on single modes or spins form a complete basis of the operator space, each physical object that is represented in struqture can be built up from sum over products of these operators, be it an operator, a Hamiltonian or a noise description.</p>
<p>These sum objects can then be represented in a sparse fashion by saving the sum as a HashMap or Dictionary where the values are the prefactors of the operator products in the sum.
The keys of the HashMap are the operator products or for noise objects tuples of operator products.</p>
<p>One of the goals of struqture is to avoid introducing unphysical behaviour by encoding guarantees into the types of operators. For operator products that are not always Hermitian, struqture provides a Hermitian variant of the operator product. This variant picks by design one of the two hermitian conjugated versions of the operator product.
It can be used to uniquely represent the coefficient in sum objects that are themselves Hermitian (Hamiltonians) where the coefficients of Hermitian conjugated operator products in the sum also need to be Hermitian conjugated.</p>
<p>The operator products in struqture are</p>
<ul>
<li><code>PauliProduct</code></li>
<li><code>DecoherenceProduct</code></li>
<li><code>FermionProduct</code></li>
<li><code>HermitianFermionProduct</code></li>
<li><code>BosonProduct</code></li>
<li><code>HermitianBosonProdcut</code></li>
<li><code>MixedProduct</code></li>
<li><code>HermitianMixedProduct</code></li>
<li><code>MixedDecoherenceProduct</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators-and-systems"><a class="header" href="#operators-and-systems">Operators and Systems</a></h1>
<p>Operators and systems act on a state space using HashMaps (Dictionaries) of operator products and values. The distinction between operators and systems is that systems are given a fixed system size by the user when creating the object.</p>
<p>For spins, the operators and systems represent
\[ 
\hat{O} = \sum_{j=0}^N \alpha_j \prod_{k} \sigma^{k}_j \\
\sigma^{k}_j \in \{ X, Y, Z, I \}
\]
where the \(\sigma^{k}_j\) are <code>SinglePauliOperators</code>.</p>
<p>For bosons, the operators and systems represent
\[ \hat{O} = \sum_{j=0}^N \alpha_j \prod_{k, l} c_{k, j}^{\dagger} c\delta_{l, j} \]
with 
\(c^{\dagger}\) the bosonic creation operator, \(c\) the bosonic annihilation operator 
\[ \lbrack c_k^{\dagger}, c_j^{\dagger} \rbrack = 0, \\
\lbrack c_k, c_j \rbrack = 0, \\
\lbrack c_k^{\dagger}, c_j \rbrack = \delta_{k, j}. \]</p>
<p>For fermions, the operators and systems represent
\[ \hat{O} = \sum_{j=0}^N \alpha_j \prod_{k, l} c_{k, j}^{\dagger} c_{l,j}  \]
with 
\(c^{\dagger}\) the fermionionic creation operator, \(c\) the fermionionic annihilation operator
\[ \lbrace c_k^{\dagger}, c_j^{\dagger} \rbrace = 0, \\
\lbrace c_k, c_j \rbrace = 0, \\
\lbrace c_k^{\dagger}, c_j \rbrace = \delta_{k, j}. \]</p>
<p>The operators and systems in struqture are</p>
<ul>
<li><code>SpinOperator</code></li>
<li><code>SpinSystem</code></li>
<li><code>DecoherenceOperator</code></li>
<li><code>FermionOperator</code></li>
<li><code>FermionSystem</code></li>
<li><code>BosonOperator</code></li>
<li><code>BosonSystem</code></li>
<li><code>MixedOperator</code></li>
<li><code>MixedSystem</code></li>
</ul>
<h1 id="hamiltonians-and-hamiltoniansystems"><a class="header" href="#hamiltonians-and-hamiltoniansystems">Hamiltonians and HamiltonianSystems</a></h1>
<p>Hamiltonians are hermitian equivalents to Operators, and HamiltonionSystems are the hermitian equivalents to Systems. The operator products for hamiltonian and hamiltonian systems are hermitian, meaning that the term is stored, as well as its hermitian conjugate. Also, in order for the hamiltonian to be hermitian, any operator product on the diagonal of the matrix of interactions must be real.</p>
<p>The hamiltonians and hamiltonian systems in struqture are</p>
<ul>
<li><code>SpinHamiltonian</code></li>
<li><code>SpinHamiltonianSystem</code></li>
<li><code>FermionHamiltonian</code></li>
<li><code>FermionHamiltonianSystem</code></li>
<li><code>BosonHamiltonian</code></li>
<li><code>BosonHamiltonianSystem</code></li>
<li><code>MixedHamiltonian</code></li>
<li><code>MixedHamiltonianSystem</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators-and-systems-1"><a class="header" href="#operators-and-systems-1">Operators and Systems</a></h1>
<p>Operators and systems act on a state space using HashMaps (Dictionaries) of operator products and values. The distinction between operators and systems is that systems are given a fixed system size by the user when creating the object.</p>
<p>For spins, the operators and systems represent
\[ 
\hat{O} = \sum_{j=0}^N \alpha_j \prod_{k} \sigma^{k}_j \\
\sigma^{k}_j \in \{ X, Y, Z, I \}
\]
where the \(\sigma^{k}_j\) are <code>SinglePauliOperators</code>.</p>
<p>For bosons, the operators and systems represent
\[ \hat{O} = \sum_{j=0}^N \alpha_j \prod_{k, l} c_{k, j}^{\dagger} c\delta_{l, j} \]
with 
\(c^{\dagger}\) the bosonic creation operator, \(c\) the bosonic annihilation operator 
\[ \lbrack c_k^{\dagger}, c_j^{\dagger} \rbrack = 0, \\
\lbrack c_k, c_j \rbrack = 0, \\
\lbrack c_k^{\dagger}, c_j \rbrack = \delta_{k, j}. \]</p>
<p>For fermions, the operators and systems represent
\[ \hat{O} = \sum_{j=0}^N \alpha_j \prod_{k, l} c_{k, j}^{\dagger} c_{l,j}  \]
with 
\(c^{\dagger}\) the fermionionic creation operator, \(c\) the fermionionic annihilation operator
\[ \lbrace c_k^{\dagger}, c_j^{\dagger} \rbrace = 0, \\
\lbrace c_k, c_j \rbrace = 0, \\
\lbrace c_k^{\dagger}, c_j \rbrace = \delta_{k, j}. \]</p>
<p>The operators and systems in struqture are</p>
<ul>
<li><code>SpinOperator</code></li>
<li><code>SpinSystem</code></li>
<li><code>DecoherenceOperator</code></li>
<li><code>FermionOperator</code></li>
<li><code>FermionSystem</code></li>
<li><code>BosonOperator</code></li>
<li><code>BosonSystem</code></li>
<li><code>MixedOperator</code></li>
<li><code>MixedSystem</code></li>
</ul>
<h1 id="hamiltonians-and-hamiltoniansystems-1"><a class="header" href="#hamiltonians-and-hamiltoniansystems-1">Hamiltonians and HamiltonianSystems</a></h1>
<p>Hamiltonians are hermitian equivalents to Operators, and HamiltonionSystems are the hermitian equivalents to Systems. The operator products for hamiltonian and hamiltonian systems are hermitian, meaning that the term is stored, as well as its hermitian conjugate. Also, in order for the hamiltonian to be hermitian, any operator product on the diagonal of the matrix of interactions must be real.</p>
<p>The hamiltonians and hamiltonian systems in struqture are</p>
<ul>
<li><code>SpinHamiltonian</code></li>
<li><code>SpinHamiltonianSystem</code></li>
<li><code>FermionHamiltonian</code></li>
<li><code>FermionHamiltonianSystem</code></li>
<li><code>BosonHamiltonian</code></li>
<li><code>BosonHamiltonianSystem</code></li>
<li><code>MixedHamiltonian</code></li>
<li><code>MixedHamiltonianSystem</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="noise-operators"><a class="header" href="#noise-operators">Noise Operators</a></h1>
<p>We describe decoherence by representing it with the Lindblad equation.
The Lindblad equation is a master equation determining the time evolution of the density matrix.
For pure noise terms it is given by
\[
\dot{\rho} = \mathcal{L}(\rho) =-i [\hat{H}, \rho] + \sum_{j,k} \Gamma_{j,k} \left( L_{j}\rho L_{k}^{\dagger} - \frac{1}{2} \{ L_k^{\dagger} L_j, \rho \} \right)
\]
with the rate matrix \(\Gamma_{j,k}\) and the Lindblad operator \(L_{j}\).</p>
<p>Each Lindblad operator is an operator product (in the spins case, a decoherence operator product - for more information see <a href="container_types/../physical_types/spins">spins container</a> chapter). LindbladNoiseOperators are built as HashMaps (Dictionaries) of Lindblad operators and values, in order to build the non-coherent part of the Lindblad master equation:
\[
\sum_{j,k} \Gamma_{j,k} \left( L_{j} \rho L_{k}^{\dagger} - \frac{1}{2} \{ L_k^{\dagger} L_j, \rho\} \right)
\].</p>
<p>The noise operators in struqture are</p>
<ul>
<li><code>SpinLindbladNoiseOperator</code></li>
<li><code>BosonLindbladNoiseOperator</code></li>
<li><code>FermionLindbladNoiseOperator</code></li>
<li><code>MixedLindbladNoiseOperator</code></li>
</ul>
<h1 id="noise-systems"><a class="header" href="#noise-systems">Noise Systems</a></h1>
<p>Noise systems are noise operators with a fixed size, which is given by the user in the <code>new</code> function.</p>
<p>The noise systems in struqture are</p>
<ul>
<li><code>SpinLindbladNoiseSystem</code></li>
<li><code>BosonLindbladNoiseSystem</code></li>
<li><code>FermionLindbladNoiseSystem</code></li>
<li><code>MixedLindbladNoiseSystem</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-systems-4"><a class="header" href="#open-systems-4">Open Systems</a></h1>
<p>Open systems represent a full system and environment. Mathematically, this means that a LindbladOpenSystem represents the entire Lindblad equation. The Lindblad equation is a master equation determining the time evolution of the density matrix:
\[
\dot{\rho} = \mathcal{L}(\rho) =-i [\hat{H}, \rho] + \sum_{j,k} \Gamma_{j,k} \left( L_{j}\rho L_{k}^{\dagger} - \frac{1}{2} \{ L_k^{\dagger} L_j, \rho \} \right)
\]
with the Hamiltonian of the system \(\hat{H}\), the rate matrix \(\Gamma_{j,k}\), and the Lindblad operator \(L_{j}\).</p>
<p>Each LindbladOpenSystem is therefore composed of a HamiltonianSystem:
\[
-i [\hat{H}, \rho]
\]</p>
<p>and a LindbladNoiseSystem:
\[
\sum_{j,k} \Gamma_{j,k} \left( L_{j} \rho L_{k}^{\dagger} - \frac{1}{2} \{ L_k^{\dagger} L_j, \rho\} \right)
\]</p>
<p>The open systems in struqture are</p>
<ul>
<li><code>SpinLindbladOpenSystem</code></li>
<li><code>BosonLindbladOpenSystem</code></li>
<li><code>FermionLindbladOpenSystem</code></li>
<li><code>MixedLindbladOpenSystem</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applied-example"><a class="header" href="#applied-example">Applied example</a></h1>
<p>In this example, we will create the spin-boson Hamiltonian we have used for open-system research in our <a href="https://arxiv.org/abs/2210.12138">paper</a>, for 1 spin and 3 bosons.</p>
<p>The Hamiltonian is as follows:
\[
\hat{H} = \hat{H}_S + \hat{H}_B + \hat{H}_C
\]</p>
<p>with the spin system Hamiltonian \(\hat{H}_S\) :</p>
<p>\[
\hat{H} = \frac {\hbar \Delta} {2} \sigma^z_0,
\]</p>
<p>the bosonic bath Hamiltonian \(\hat{H}_B\) :</p>
<p>\[ 
\hat{H} = \sum_{k=0}^2 \hbar \omega_k c_k^{\dagger} c_k,
\]</p>
<p>and the coupling between system and bath \(\hat{H}_C\) :</p>
<p>\[ 
\hat{H} = \sigma_0^x \sum_{k=0}^2 \frac {v_k} {2} \left( c_k + c_k^{\dagger} \right)
\]</p>
<p>For simplicity, we will set \(\hbar\) to 1.0 for this example.</p>
<p>Rust implementation:</p>
<pre><code class="language-rust">use qoqo_calculator::CalculatorComplex;
use struqture::bosons::BosonProduct;
use struqture::mixed_systems::{
    HermitianMixedProduct, MixedHamiltonianSystem,
};
use struqture::prelude::*;
use struqture::spins::PauliProduct;

let mut system = MixedHamiltonianSystem::new([Some(1)], [Some(3)], []);

// Setting up constants:
let delta = 1.0;
let omega_k = [2.0, 3.0, 4.0];
let v_k = [5.0, 6.0, 7.0];

// First, H_S:
let pp = PauliProduct::new().z(1);
let hmp = HermitianMixedProduct::new(
    [pp], [BosonProduct::new([], []).unwrap()], []
).unwrap();
system
    .add_operator_product(hmp, CalculatorComplex::new(delta / 2.0, 0.0))
    .unwrap();

// Second, H_B:
for k in 0..3 {
    let bp = BosonProduct::new([k], [k]).unwrap();
    let hmp = HermitianMixedProduct::new(
        [PauliProduct::new()], [bp], []
    ).unwrap();
    system
        .add_operator_product(
            hmp, CalculatorComplex::new(v_k[k] / 2.0, 0.0)
        ).unwrap();
}

// Third, H_C: the hermitian conjugate is implicitly stored,
// we don't need to add it manually
let pp = PauliProduct::new().x(0);
for k in 0..3 {
    let bp = BosonProduct::new([], [k]).unwrap();
    let hmp = HermitianMixedProduct::new([pp.clone()], [bp], []).unwrap();
    system
        .add_operator_product(
            hmp, CalculatorComplex::new(omega_k[k], 0.0)
        ).unwrap();
}

// Our resulting H:
println!(&quot;{}&quot;, system);</code></pre>
<p>Python implementation:</p>
<pre><code class="language-python">from qoqo_calculator_pyo3 import CalculatorComplex
from struqture_py.bosons import BosonProduct
from struqture_py.mixed_systems import (
    HermitianMixedProduct, HermitianMixedProduct, MixedHamiltonianSystem,
)
from struqture_py.spins import (PauliProduct, PauliProduct)


system = MixedHamiltonianSystem([1], [3], [])

# Setting up constants:
delta = 1.0
omega_k = [2.0, 3.0, 4.0]
v_k = [5.0, 6.0, 7.0]

# First, H_S:
pp = PauliProduct().z(1)
hmp = HermitianMixedProduct([pp], [BosonProduct([], [])], [])
system.add_operator_product(
    hmp, CalculatorComplex.from_pair(delta / 2.0, 0.0)
)

# Second, H_B:
for k in range(3):
    bp = BosonProduct([k], [k])
    hmp = HermitianMixedProduct([PauliProduct()], [bp], [])
    system.add_operator_product(
        hmp, CalculatorComplex.from_pair(v_k[k] / 2.0, 0.0)
    )

# Third, H_C: the hermitian conjugate is implicitly stored,
# we don't need to add it manually
pp = PauliProduct().x(0)
for k in range(3):
    bp = BosonProduct([], [k])
    hmp = HermitianMixedProduct([pp], [bp], [])
    system.add_operator_product(
        hmp, CalculatorComplex.from_pair(omega_k[k], 0.0)
    )


# Our resulting H:
print(system)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>
        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
